/**
 * Endpoints
 * Endpoints API for different services in SKIL
 *
 * OpenAPI spec version: 1.1.0-beta
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package ai.skymind.skil

import java.text.SimpleDateFormat

import ai.skymind.skil.model.AddExampleRequest
import ai.skymind.skil.model.AddModelHistoryRequest
import ai.skymind.skil.model.AggregatePrediction
import ai.skymind.skil.model.ArrayByte
import ai.skymind.skil.model.Base64NDArrayBody
import ai.skymind.skil.model.Base64NDArrayBodyKNN
import ai.skymind.skil.model.BatchCSVRecord
import ai.skymind.skil.model.BatchImageRecord
import ai.skymind.skil.model.BestModel
import ai.skymind.skil.model.ClassificationResult
import ai.skymind.skil.model.CreateDeploymentRequest
import ai.skymind.skil.model.Credentials
import ai.skymind.skil.model.DeploymentResponse
import ai.skymind.skil.model.DetectionResult
import ai.skymind.skil.model.EvaluationResultsEntity
import ai.skymind.skil.model.ExampleEntity
import ai.skymind.skil.model.ExperimentEntity
import java.io.File
import ai.skymind.skil.model.FileUploadList
import ai.skymind.skil.model.ImageTransformProcess
import ai.skymind.skil.model.ImportModelRequest
import ai.skymind.skil.model.InlineResponse200
import ai.skymind.skil.model.JsonArrayResponse
import ai.skymind.skil.model.LogBatch
import ai.skymind.skil.model.LogRequest
import ai.skymind.skil.model.MetaData
import ai.skymind.skil.model.MinibatchEntity
import ai.skymind.skil.model.ModelEntity
import ai.skymind.skil.model.ModelFeedBackRequest
import ai.skymind.skil.model.ModelHistoryEntity
import ai.skymind.skil.model.ModelInstanceEntity
import ai.skymind.skil.model.ModelStatus
import ai.skymind.skil.model.MultiClassClassificationResult
import ai.skymind.skil.model.MultiPredictRequest
import ai.skymind.skil.model.MultiPredictResponse
import ai.skymind.skil.model.NearestNeighborRequest
import ai.skymind.skil.model.NearestNeighborsResults
import ai.skymind.skil.model.Prediction
import ai.skymind.skil.model.SetState
import ai.skymind.skil.model.SingleCSVRecord
import ai.skymind.skil.model.SingleImageRecord
import ai.skymind.skil.model.Token
import ai.skymind.skil.model.TransformProcess
import ai.skymind.skil.model.UpdateBestModel
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class DefaultApi(
  val defBasePath: String = "http://localhost:9008",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new DefaultApiAsyncHelper(client, config)

  /**
   * Adds an evaluation result
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param EvaluationResultsEntity The evaluation result entity 
   * @return EvaluationResultsEntity
   */
  def addEvaluationResult(ModelHistoryServerId: String, EvaluationResultsEntity: EvaluationResultsEntity): Option[EvaluationResultsEntity] = {
    val await = Try(Await.result(addEvaluationResultAsync(ModelHistoryServerId, EvaluationResultsEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds an evaluation result asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param EvaluationResultsEntity The evaluation result entity 
   * @return Future(EvaluationResultsEntity)
   */
  def addEvaluationResultAsync(ModelHistoryServerId: String, EvaluationResultsEntity: EvaluationResultsEntity): Future[EvaluationResultsEntity] = {
      helper.addEvaluationResult(ModelHistoryServerId, EvaluationResultsEntity)
  }

  /**
   * Adds a number of examples to a minibatch ID given an AddExampleRequest.
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddExampleRequest The add example request, encapsulating minibatch details and examples batch size 
   * @return AddExampleRequest
   */
  def addExampleForBatch(ModelHistoryServerId: String, AddExampleRequest: AddExampleRequest): Option[AddExampleRequest] = {
    val await = Try(Await.result(addExampleForBatchAsync(ModelHistoryServerId, AddExampleRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a number of examples to a minibatch ID given an AddExampleRequest. asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddExampleRequest The add example request, encapsulating minibatch details and examples batch size 
   * @return Future(AddExampleRequest)
   */
  def addExampleForBatchAsync(ModelHistoryServerId: String, AddExampleRequest: AddExampleRequest): Future[AddExampleRequest] = {
      helper.addExampleForBatch(ModelHistoryServerId, AddExampleRequest)
  }

  /**
   * Adds an example to a minibatch
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExampleEntity The example to add to the minibatch 
   * @return ExampleEntity
   */
  def addExampleToMinibatch(ModelHistoryServerId: String, ExampleEntity: ExampleEntity): Option[ExampleEntity] = {
    val await = Try(Await.result(addExampleToMinibatchAsync(ModelHistoryServerId, ExampleEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds an example to a minibatch asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExampleEntity The example to add to the minibatch 
   * @return Future(ExampleEntity)
   */
  def addExampleToMinibatchAsync(ModelHistoryServerId: String, ExampleEntity: ExampleEntity): Future[ExampleEntity] = {
      helper.addExampleToMinibatch(ModelHistoryServerId, ExampleEntity)
  }

  /**
   * Add an experiment, given an experiment entity
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentEntity The experiment entity to add 
   * @return ExperimentEntity
   */
  def addExperiment(ModelHistoryServerId: String, ExperimentEntity: ExperimentEntity): Option[ExperimentEntity] = {
    val await = Try(Await.result(addExperimentAsync(ModelHistoryServerId, ExperimentEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add an experiment, given an experiment entity asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentEntity The experiment entity to add 
   * @return Future(ExperimentEntity)
   */
  def addExperimentAsync(ModelHistoryServerId: String, ExperimentEntity: ExperimentEntity): Future[ExperimentEntity] = {
      helper.addExperiment(ModelHistoryServerId, ExperimentEntity)
  }

  /**
   * Adds a minibatch
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchEntity The minibatch entity to add 
   * @return MinibatchEntity
   */
  def addMinibatch(ModelHistoryServerId: String, MinibatchEntity: MinibatchEntity): Option[MinibatchEntity] = {
    val await = Try(Await.result(addMinibatchAsync(ModelHistoryServerId, MinibatchEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a minibatch asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchEntity The minibatch entity to add 
   * @return Future(MinibatchEntity)
   */
  def addMinibatchAsync(ModelHistoryServerId: String, MinibatchEntity: MinibatchEntity): Future[MinibatchEntity] = {
      helper.addMinibatch(ModelHistoryServerId, MinibatchEntity)
  }

  /**
   * Adds an evaluation feedback to the model against a given minibatch id.
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelFeedBackRequest The model feedback request object 
   * @return ModelFeedBackRequest
   */
  def addModelFeedback(ModelHistoryServerId: String, ModelFeedBackRequest: ModelFeedBackRequest): Option[ModelFeedBackRequest] = {
    val await = Try(Await.result(addModelFeedbackAsync(ModelHistoryServerId, ModelFeedBackRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds an evaluation feedback to the model against a given minibatch id. asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelFeedBackRequest The model feedback request object 
   * @return Future(ModelFeedBackRequest)
   */
  def addModelFeedbackAsync(ModelHistoryServerId: String, ModelFeedBackRequest: ModelFeedBackRequest): Future[ModelFeedBackRequest] = {
      helper.addModelFeedback(ModelHistoryServerId, ModelFeedBackRequest)
  }

  /**
   * Add a model history / workspace
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddModelHistoryRequest The model history request object 
   * @return ModelHistoryEntity
   */
  def addModelHistory(ModelHistoryServerId: String, AddModelHistoryRequest: AddModelHistoryRequest): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(addModelHistoryAsync(ModelHistoryServerId, AddModelHistoryRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a model history / workspace asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AddModelHistoryRequest The model history request object 
   * @return Future(ModelHistoryEntity)
   */
  def addModelHistoryAsync(ModelHistoryServerId: String, AddModelHistoryRequest: AddModelHistoryRequest): Future[ModelHistoryEntity] = {
      helper.addModelHistory(ModelHistoryServerId, AddModelHistoryRequest)
  }

  /**
   * Adds a model
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceEntity The object encapsulating the model instance id and evaluation type to aggregate 
   * @return ModelInstanceEntity
   */
  def addModelInstance(ModelHistoryServerId: String, ModelInstanceEntity: ModelInstanceEntity): Option[ModelInstanceEntity] = {
    val await = Try(Await.result(addModelInstanceAsync(ModelHistoryServerId, ModelInstanceEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a model asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceEntity The object encapsulating the model instance id and evaluation type to aggregate 
   * @return Future(ModelInstanceEntity)
   */
  def addModelInstanceAsync(ModelHistoryServerId: String, ModelInstanceEntity: ModelInstanceEntity): Future[ModelInstanceEntity] = {
      helper.addModelInstance(ModelHistoryServerId, ModelInstanceEntity)
  }

  /**
   * Aggregates the evaluaition results of a model instance, based on the evaluation type
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AggregatePrediction The object encapsulating the model instance id and evaluation type to aggregate 
   * @return EvaluationResultsEntity
   */
  def aggregateModelResults(ModelHistoryServerId: String, AggregatePrediction: AggregatePrediction): Option[EvaluationResultsEntity] = {
    val await = Try(Await.result(aggregateModelResultsAsync(ModelHistoryServerId, AggregatePrediction), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Aggregates the evaluaition results of a model instance, based on the evaluation type asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param AggregatePrediction The object encapsulating the model instance id and evaluation type to aggregate 
   * @return Future(EvaluationResultsEntity)
   */
  def aggregateModelResultsAsync(ModelHistoryServerId: String, AggregatePrediction: AggregatePrediction): Future[EvaluationResultsEntity] = {
      helper.aggregateModelResults(ModelHistoryServerId, AggregatePrediction)
  }

  /**
   * Use the deployed model to classify the input
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return ClassificationResult
   */
  def classify(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Option[ClassificationResult] = {
    val await = Try(Await.result(classifyAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Use the deployed model to classify the input asynchronously
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(ClassificationResult)
   */
  def classifyAsync(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Future[ClassificationResult] = {
      helper.classify(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Same as /classify but returns the output as Base64NDArrayBody
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Base64NDArrayBody
   */
  def classifyarray(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(classifyarrayAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Same as /classify but returns the output as Base64NDArrayBody asynchronously
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(Base64NDArrayBody)
   */
  def classifyarrayAsync(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Future[Base64NDArrayBody] = {
      helper.classifyarray(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Use the deployed model to classify the input, using input image file from multipart form data.
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param Image The file to upload. (optional)
   * @return ClassificationResult
   */
  def classifyimage(DeploymentName: String, VersionName: String, ModelName: String, Image: Option[File] = None): Option[ClassificationResult] = {
    val await = Try(Await.result(classifyimageAsync(DeploymentName, VersionName, ModelName, Image), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Use the deployed model to classify the input, using input image file from multipart form data. asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param Image The file to upload. (optional)
   * @return Future(ClassificationResult)
   */
  def classifyimageAsync(DeploymentName: String, VersionName: String, ModelName: String, Image: Option[File] = None): Future[ClassificationResult] = {
      helper.classifyimage(DeploymentName, VersionName, ModelName, Image)
  }

  /**
   * Creates model History
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryEntity The model history entity 
   * @return ModelHistoryEntity
   */
  def createModelHistory(ModelHistoryServerId: String, ModelHistoryEntity: ModelHistoryEntity): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(createModelHistoryAsync(ModelHistoryServerId, ModelHistoryEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Creates model History asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryEntity The model history entity 
   * @return Future(ModelHistoryEntity)
   */
  def createModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryEntity: ModelHistoryEntity): Future[ModelHistoryEntity] = {
      helper.createModelHistory(ModelHistoryServerId, ModelHistoryEntity)
  }

  /**
   * Deletes an experiment, given an experiment entity
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to delete 
   * @return InlineResponse200
   */
  def deleteExperiment(ModelHistoryServerId: String, ExperimentID: String): Option[InlineResponse200] = {
    val await = Try(Await.result(deleteExperimentAsync(ModelHistoryServerId, ExperimentID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes an experiment, given an experiment entity asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to delete 
   * @return Future(InlineResponse200)
   */
  def deleteExperimentAsync(ModelHistoryServerId: String, ExperimentID: String): Future[InlineResponse200] = {
      helper.deleteExperiment(ModelHistoryServerId, ExperimentID)
  }

  /**
   * Delete a model by deployment and model id
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @return InlineResponse200
   */
  def deleteModel(DeploymentId: String, ModelId: String): Option[InlineResponse200] = {
    val await = Try(Await.result(deleteModelAsync(DeploymentId, ModelId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a model by deployment and model id asynchronously
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @return Future(InlineResponse200)
   */
  def deleteModelAsync(DeploymentId: String, ModelId: String): Future[InlineResponse200] = {
      helper.deleteModel(DeploymentId, ModelId)
  }

  /**
   * Deletes a model history / workspace, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to delete 
   * @return InlineResponse200
   */
  def deleteModelHistory(ModelHistoryServerId: String, ModelHistoryID: String): Option[InlineResponse200] = {
    val await = Try(Await.result(deleteModelHistoryAsync(ModelHistoryServerId, ModelHistoryID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes a model history / workspace, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to delete 
   * @return Future(InlineResponse200)
   */
  def deleteModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String): Future[InlineResponse200] = {
      helper.deleteModelHistory(ModelHistoryServerId, ModelHistoryID)
  }

  /**
   * Deletes a model instance, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to delete. 
   * @return void
   */
  def deleteModelInstance(ModelHistoryServerId: String, ModelInstanceID: String) = {
    val await = Try(Await.result(deleteModelInstanceAsync(ModelHistoryServerId, ModelInstanceID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes a model instance, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to delete. 
   * @return Future(void)
   */
  def deleteModelInstanceAsync(ModelHistoryServerId: String, ModelInstanceID: String) = {
      helper.deleteModelInstance(ModelHistoryServerId, ModelInstanceID)
  }

  /**
   * Deploy a model in a deployment group.
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param Body the model import request 
   * @return ModelEntity
   */
  def deployModel(DeploymentId: String, Body: ImportModelRequest): Option[ModelEntity] = {
    val await = Try(Await.result(deployModelAsync(DeploymentId, Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deploy a model in a deployment group. asynchronously
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param Body the model import request 
   * @return Future(ModelEntity)
   */
  def deployModelAsync(DeploymentId: String, Body: ImportModelRequest): Future[ModelEntity] = {
      helper.deployModel(DeploymentId, Body)
  }

  /**
   * Create a new deployment group.
   * 
   *
   * @param Body the deployment request 
   * @return DeploymentResponse
   */
  def deploymentCreate(Body: CreateDeploymentRequest): Option[DeploymentResponse] = {
    val await = Try(Await.result(deploymentCreateAsync(Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a new deployment group. asynchronously
   * 
   *
   * @param Body the deployment request 
   * @return Future(DeploymentResponse)
   */
  def deploymentCreateAsync(Body: CreateDeploymentRequest): Future[DeploymentResponse] = {
      helper.deploymentCreate(Body)
  }

  /**
   * Delete a deployment by id
   * 
   *
   * @param DeploymentId Id of the deployment group 
   * @return InlineResponse200
   */
  def deploymentDelete(DeploymentId: String): Option[InlineResponse200] = {
    val await = Try(Await.result(deploymentDeleteAsync(DeploymentId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a deployment by id asynchronously
   * 
   *
   * @param DeploymentId Id of the deployment group 
   * @return Future(InlineResponse200)
   */
  def deploymentDeleteAsync(DeploymentId: String): Future[InlineResponse200] = {
      helper.deploymentDelete(DeploymentId)
  }

  /**
   * Get a deployment details by id
   * 
   *
   * @param DeploymentId Id of the deployment group 
   * @return DeploymentResponse
   */
  def deploymentGet(DeploymentId: String): Option[DeploymentResponse] = {
    val await = Try(Await.result(deploymentGetAsync(DeploymentId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a deployment details by id asynchronously
   * 
   *
   * @param DeploymentId Id of the deployment group 
   * @return Future(DeploymentResponse)
   */
  def deploymentGetAsync(DeploymentId: String): Future[DeploymentResponse] = {
      helper.deploymentGet(DeploymentId)
  }

  /**
   * Get a list of deployments
   * 
   *
   * @return List[DeploymentResponse]
   */
  def deployments(): Option[List[DeploymentResponse]] = {
    val await = Try(Await.result(deploymentsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a list of deployments asynchronously
   * 
   *
   * @return Future(List[DeploymentResponse])
   */
  def deploymentsAsync(): Future[List[DeploymentResponse]] = {
      helper.deployments()
  }

  /**
   * Detect the objects, given a (input) prediction request
   * 
   *
   * @param Id the GUID for mapping the results in the detections 
   * @param NeedsPreprocessing (true) if the image needs preprocessing 
   * @param Threshold A threshold, indicating the required surety for detecting a bounding box. For example, a threshold of 0.1 might give thousand bounding boxes for an image and a threshold of 0.99 might give none. 
   * @param ImageFile the image file to detect objects from 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return DetectionResult
   */
  def detectobjects(Id: String, NeedsPreprocessing: Boolean, Threshold: Float, ImageFile: File, DeploymentName: String, VersionName: String, ModelName: String): Option[DetectionResult] = {
    val await = Try(Await.result(detectobjectsAsync(Id, NeedsPreprocessing, Threshold, ImageFile, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Detect the objects, given a (input) prediction request asynchronously
   * 
   *
   * @param Id the GUID for mapping the results in the detections 
   * @param NeedsPreprocessing (true) if the image needs preprocessing 
   * @param Threshold A threshold, indicating the required surety for detecting a bounding box. For example, a threshold of 0.1 might give thousand bounding boxes for an image and a threshold of 0.99 might give none. 
   * @param ImageFile the image file to detect objects from 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(DetectionResult)
   */
  def detectobjectsAsync(Id: String, NeedsPreprocessing: Boolean, Threshold: Float, ImageFile: File, DeploymentName: String, VersionName: String, ModelName: String): Future[DetectionResult] = {
      helper.detectobjects(Id, NeedsPreprocessing, Threshold, ImageFile, DeploymentName, VersionName, ModelName)
  }

  /**
   * Gets the best model among the given model instance IDs, based on the evaluation type and column metric
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param BestModel Object encapsulating the model ids, eval type and column metric name 
   * @return ModelInstanceEntity
   */
  def getBestModelAmongModelIds(ModelHistoryServerId: String, BestModel: BestModel): Option[ModelInstanceEntity] = {
    val await = Try(Await.result(getBestModelAmongModelIdsAsync(ModelHistoryServerId, BestModel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the best model among the given model instance IDs, based on the evaluation type and column metric asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param BestModel Object encapsulating the model ids, eval type and column metric name 
   * @return Future(ModelInstanceEntity)
   */
  def getBestModelAmongModelIdsAsync(ModelHistoryServerId: String, BestModel: BestModel): Future[ModelInstanceEntity] = {
      helper.getBestModelAmongModelIds(ModelHistoryServerId, BestModel)
  }

  /**
   * Gets the list of evaluation results entity, given a model instance ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get evaluation results for. 
   * @return List[EvaluationResultsEntity]
   */
  def getEvaluationForModelID(ModelHistoryServerId: String, ModelInstanceID: String): Option[List[EvaluationResultsEntity]] = {
    val await = Try(Await.result(getEvaluationForModelIDAsync(ModelHistoryServerId, ModelInstanceID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the list of evaluation results entity, given a model instance ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get evaluation results for. 
   * @return Future(List[EvaluationResultsEntity])
   */
  def getEvaluationForModelIDAsync(ModelHistoryServerId: String, ModelInstanceID: String): Future[List[EvaluationResultsEntity]] = {
      helper.getEvaluationForModelID(ModelHistoryServerId, ModelInstanceID)
  }

  /**
   * Gets all the examples for a minibatch ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return List[ExampleEntity]
   */
  def getExamplesForMinibatch(ModelHistoryServerId: String, MinibatchId: String): Option[List[ExampleEntity]] = {
    val await = Try(Await.result(getExamplesForMinibatchAsync(ModelHistoryServerId, MinibatchId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets all the examples for a minibatch ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return Future(List[ExampleEntity])
   */
  def getExamplesForMinibatchAsync(ModelHistoryServerId: String, MinibatchId: String): Future[List[ExampleEntity]] = {
      helper.getExamplesForMinibatch(ModelHistoryServerId, MinibatchId)
  }

  /**
   * Obtain an experiment&#39;s details, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to obtain 
   * @return ExperimentEntity
   */
  def getExperiment(ModelHistoryServerId: String, ExperimentID: String): Option[ExperimentEntity] = {
    val await = Try(Await.result(getExperimentAsync(ModelHistoryServerId, ExperimentID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Obtain an experiment&#39;s details, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to obtain 
   * @return Future(ExperimentEntity)
   */
  def getExperimentAsync(ModelHistoryServerId: String, ExperimentID: String): Future[ExperimentEntity] = {
      helper.getExperiment(ModelHistoryServerId, ExperimentID)
  }

  /**
   * Obtain all experiments for a model history / workspace
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace 
   * @return ExperimentEntity
   */
  def getExperimentsForModelHistory(ModelHistoryServerId: String, ModelHistoryID: String): Option[ExperimentEntity] = {
    val await = Try(Await.result(getExperimentsForModelHistoryAsync(ModelHistoryServerId, ModelHistoryID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Obtain all experiments for a model history / workspace asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace 
   * @return Future(ExperimentEntity)
   */
  def getExperimentsForModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String): Future[ExperimentEntity] = {
      helper.getExperimentsForModelHistory(ModelHistoryServerId, ModelHistoryID)
  }

  /**
   * Gets a minibatch for the model
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return MinibatchEntity
   */
  def getMinibatch(ModelHistoryServerId: String, MinibatchId: String): Option[MinibatchEntity] = {
    val await = Try(Await.result(getMinibatchAsync(ModelHistoryServerId, MinibatchId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets a minibatch for the model asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param MinibatchId The GUID of the minibatch 
   * @return Future(MinibatchEntity)
   */
  def getMinibatchAsync(ModelHistoryServerId: String, MinibatchId: String): Future[MinibatchEntity] = {
      helper.getMinibatch(ModelHistoryServerId, MinibatchId)
  }

  /**
   * Gets a model history, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID GUID of the model history to get information of. 
   * @return ModelHistoryEntity
   */
  def getModelHistory(ModelHistoryServerId: String, ModelHistoryID: String): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(getModelHistoryAsync(ModelHistoryServerId, ModelHistoryID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets a model history, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID GUID of the model history to get information of. 
   * @return Future(ModelHistoryEntity)
   */
  def getModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String): Future[ModelHistoryEntity] = {
      helper.getModelHistory(ModelHistoryServerId, ModelHistoryID)
  }

  /**
   * Gets a model instance, given its ID
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get information of. 
   * @return ModelInstanceEntity
   */
  def getModelInstance(ModelHistoryServerId: String, ModelInstanceID: String): Option[ModelInstanceEntity] = {
    val await = Try(Await.result(getModelInstanceAsync(ModelHistoryServerId, ModelInstanceID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets a model instance, given its ID asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelInstanceID GUID of the model instance to get information of. 
   * @return Future(ModelInstanceEntity)
   */
  def getModelInstanceAsync(ModelHistoryServerId: String, ModelInstanceID: String): Future[ModelInstanceEntity] = {
      helper.getModelInstance(ModelHistoryServerId, ModelInstanceID)
  }

  /**
   * Obtain a list of all the models for an experiment
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment 
   * @return List[ModelInstanceEntity]
   */
  def getModelsForExperiment(ModelHistoryServerId: String, ExperimentID: String): Option[List[ModelInstanceEntity]] = {
    val await = Try(Await.result(getModelsForExperimentAsync(ModelHistoryServerId, ExperimentID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Obtain a list of all the models for an experiment asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment 
   * @return Future(List[ModelInstanceEntity])
   */
  def getModelsForExperimentAsync(ModelHistoryServerId: String, ExperimentID: String): Future[List[ModelInstanceEntity]] = {
      helper.getModelsForExperiment(ModelHistoryServerId, ExperimentID)
  }

  /**
   * Retrieves the image transform process JSON string
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @return ImageTransformProcess
   */
  def imagetransformprocessGet(DeploymentName: String, VersionName: String, ImageTransformName: String): Option[ImageTransformProcess] = {
    val await = Try(Await.result(imagetransformprocessGetAsync(DeploymentName, VersionName, ImageTransformName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Retrieves the image transform process JSON string asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @return Future(ImageTransformProcess)
   */
  def imagetransformprocessGetAsync(DeploymentName: String, VersionName: String, ImageTransformName: String): Future[ImageTransformProcess] = {
      helper.imagetransformprocessGet(DeploymentName, VersionName, ImageTransformName)
  }

  /**
   * Sets the image transform process through the provided JSON string
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param Body The image transform process JSON 
   * @return ImageTransformProcess
   */
  def imagetransformprocessPost(DeploymentName: String, VersionName: String, ImageTransformName: String, Body: ImageTransformProcess): Option[ImageTransformProcess] = {
    val await = Try(Await.result(imagetransformprocessPostAsync(DeploymentName, VersionName, ImageTransformName, Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Sets the image transform process through the provided JSON string asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param Body The image transform process JSON 
   * @return Future(ImageTransformProcess)
   */
  def imagetransformprocessPostAsync(DeploymentName: String, VersionName: String, ImageTransformName: String, Body: ImageTransformProcess): Future[ImageTransformProcess] = {
      helper.imagetransformprocessPost(DeploymentName, VersionName, ImageTransformName, Body)
  }

  /**
   * Run inference on the input and returns it as a JsonArrayResponse
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return JsonArrayResponse
   */
  def jsonarray(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Option[JsonArrayResponse] = {
    val await = Try(Await.result(jsonarrayAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Run inference on the input and returns it as a JsonArrayResponse asynchronously
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(JsonArrayResponse)
   */
  def jsonarrayAsync(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Future[JsonArrayResponse] = {
      helper.jsonarray(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Runs knn on the given index with the given k
   * Runs knn on the given index with the given k (note that this is for data already within the existing dataset not new data)
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param KnnName ID or name of the deployed knn 
   * @param Body  
   * @return NearestNeighborsResults
   */
  def knn(DeploymentName: String, VersionName: String, KnnName: String, Body: NearestNeighborRequest): Option[NearestNeighborsResults] = {
    val await = Try(Await.result(knnAsync(DeploymentName, VersionName, KnnName, Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Runs knn on the given index with the given k asynchronously
   * Runs knn on the given index with the given k (note that this is for data already within the existing dataset not new data)
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param KnnName ID or name of the deployed knn 
   * @param Body  
   * @return Future(NearestNeighborsResults)
   */
  def knnAsync(DeploymentName: String, VersionName: String, KnnName: String, Body: NearestNeighborRequest): Future[NearestNeighborsResults] = {
      helper.knn(DeploymentName, VersionName, KnnName, Body)
  }

  /**
   * Run a k nearest neighbors search on a NEW data point
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param KnnName ID or name of the deployed knn 
   * @param Body The input NDArray 
   * @return NearestNeighborsResults
   */
  def knnnew(DeploymentName: String, VersionName: String, KnnName: String, Body: Base64NDArrayBodyKNN): Option[NearestNeighborsResults] = {
    val await = Try(Await.result(knnnewAsync(DeploymentName, VersionName, KnnName, Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Run a k nearest neighbors search on a NEW data point asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param KnnName ID or name of the deployed knn 
   * @param Body The input NDArray 
   * @return Future(NearestNeighborsResults)
   */
  def knnnewAsync(DeploymentName: String, VersionName: String, KnnName: String, Body: Base64NDArrayBodyKNN): Future[NearestNeighborsResults] = {
      helper.knnnew(DeploymentName, VersionName, KnnName, Body)
  }

  /**
   * List all of the experiments in every model history / workspace
   * 
   *
   * @return List[ExperimentEntity]
   */
  def listAllExperiments(): Option[List[ExperimentEntity]] = {
    val await = Try(Await.result(listAllExperimentsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List all of the experiments in every model history / workspace asynchronously
   * 
   *
   * @return Future(List[ExperimentEntity])
   */
  def listAllExperimentsAsync(): Future[List[ExperimentEntity]] = {
      helper.listAllExperiments()
  }

  /**
   * Get logs file path
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return String
   */
  def logfilepath(DeploymentName: String, VersionName: String, ModelName: String): Option[String] = {
    val await = Try(Await.result(logfilepathAsync(DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get logs file path asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(String)
   */
  def logfilepathAsync(DeploymentName: String, VersionName: String, ModelName: String): Future[String] = {
      helper.logfilepath(DeploymentName, VersionName, ModelName)
  }

  /**
   * Post JSON credentials and obtain a JWT authorization token.
   * 
   *
   * @param Credentials Login credentials. 
   * @return Token
   */
  def login(Credentials: Credentials): Option[Token] = {
    val await = Try(Await.result(loginAsync(Credentials), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Post JSON credentials and obtain a JWT authorization token. asynchronously
   * 
   *
   * @param Credentials Login credentials. 
   * @return Future(Token)
   */
  def loginAsync(Credentials: Credentials): Future[Token] = {
      helper.login(Credentials)
  }

  /**
   * Get logs
   * 
   *
   * @param Body the the log request 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return LogBatch
   */
  def logs(Body: LogRequest, DeploymentName: String, VersionName: String, ModelName: String): Option[LogBatch] = {
    val await = Try(Await.result(logsAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get logs asynchronously
   * 
   *
   * @param Body the the log request 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(LogBatch)
   */
  def logsAsync(Body: LogRequest, DeploymentName: String, VersionName: String, ModelName: String): Future[LogBatch] = {
      helper.logs(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * this method can be used to get the meta data for the current model which set to the server
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return MetaData
   */
  def metaGet(DeploymentName: String, VersionName: String, ModelName: String): Option[MetaData] = {
    val await = Try(Await.result(metaGetAsync(DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * this method can be used to get the meta data for the current model which set to the server asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(MetaData)
   */
  def metaGetAsync(DeploymentName: String, VersionName: String, ModelName: String): Future[MetaData] = {
      helper.metaGet(DeploymentName, VersionName, ModelName)
  }

  /**
   * This method can be used to set meta data for the current model which is set to the server
   * 
   *
   * @param Body the meta data object 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return MetaData
   */
  def metaPost(Body: MetaData, DeploymentName: String, VersionName: String, ModelName: String): Option[MetaData] = {
    val await = Try(Await.result(metaPostAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * This method can be used to set meta data for the current model which is set to the server asynchronously
   * 
   *
   * @param Body the meta data object 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(MetaData)
   */
  def metaPostAsync(Body: MetaData, DeploymentName: String, VersionName: String, ModelName: String): Future[MetaData] = {
      helper.metaPost(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Modify the state (start/stop) of a deployed model
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @param Body the model state object 
   * @return ModelEntity
   */
  def modelStateChange(DeploymentId: String, ModelId: String, Body: SetState): Option[ModelEntity] = {
    val await = Try(Await.result(modelStateChangeAsync(DeploymentId, ModelId, Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Modify the state (start/stop) of a deployed model asynchronously
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @param Body the model state object 
   * @return Future(ModelEntity)
   */
  def modelStateChangeAsync(DeploymentId: String, ModelId: String, Body: SetState): Future[ModelEntity] = {
      helper.modelStateChange(DeploymentId, ModelId, Body)
  }

  /**
   * Retrieve a list of all the deployed models given a deployment id
   * 
   *
   * @param DeploymentId ID deployment group 
   * @return List[ModelEntity]
   */
  def models(DeploymentId: String): Option[List[ModelEntity]] = {
    val await = Try(Await.result(modelsAsync(DeploymentId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Retrieve a list of all the deployed models given a deployment id asynchronously
   * 
   *
   * @param DeploymentId ID deployment group 
   * @return Future(List[ModelEntity])
   */
  def modelsAsync(DeploymentId: String): Future[List[ModelEntity]] = {
      helper.models(DeploymentId)
  }

  /**
   * Set the model to be served
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param File The model file to upload (.pb file) (optional)
   * @return ModelStatus
   */
  def modelset(DeploymentName: String, VersionName: String, ModelName: String, File: Option[File] = None): Option[ModelStatus] = {
    val await = Try(Await.result(modelsetAsync(DeploymentName, VersionName, ModelName, File), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set the model to be served asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param File The model file to upload (.pb file) (optional)
   * @return Future(ModelStatus)
   */
  def modelsetAsync(DeploymentName: String, VersionName: String, ModelName: String, File: Option[File] = None): Future[ModelStatus] = {
      helper.modelset(DeploymentName, VersionName, ModelName, File)
  }

  /**
   * Update the model to be served
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param File The model file to update with (.pb file) (optional)
   * @return ModelStatus
   */
  def modelupdate(DeploymentName: String, VersionName: String, ModelName: String, File: Option[File] = None): Option[ModelStatus] = {
    val await = Try(Await.result(modelupdateAsync(DeploymentName, VersionName, ModelName, File), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update the model to be served asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param File The model file to update with (.pb file) (optional)
   * @return Future(ModelStatus)
   */
  def modelupdateAsync(DeploymentName: String, VersionName: String, ModelName: String, File: Option[File] = None): Future[ModelStatus] = {
      helper.modelupdate(DeploymentName, VersionName, ModelName, File)
  }

  /**
   * Represents all of the labels for a given classification
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return MultiClassClassificationResult
   */
  def multiclassify(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Option[MultiClassClassificationResult] = {
    val await = Try(Await.result(multiclassifyAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Represents all of the labels for a given classification asynchronously
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(MultiClassClassificationResult)
   */
  def multiclassifyAsync(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Future[MultiClassClassificationResult] = {
      helper.multiclassify(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Get the output from the network, based on the given INDArray[] input
   * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   *
   * @param Body The multiple input arrays with mask inputs to run inferences on 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return MultiPredictResponse
   */
  def multipredict(Body: MultiPredictRequest, DeploymentName: String, VersionName: String, ModelName: String): Option[MultiPredictResponse] = {
    val await = Try(Await.result(multipredictAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the output from the network, based on the given INDArray[] input asynchronously
   * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   *
   * @param Body The multiple input arrays with mask inputs to run inferences on 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(MultiPredictResponse)
   */
  def multipredictAsync(Body: MultiPredictRequest, DeploymentName: String, VersionName: String, ModelName: String): Future[MultiPredictResponse] = {
      helper.multipredict(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Get the output from the network using the given image file using the /multipredict endpoint&#39;s method
   * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   *
   * @param File The image file to run the prediction on 
   * @param Id The id of the request (could be self generated) 
   * @param NeedsPreprocessing Whether or not the preprocessing is required (either &#39;true&#39; or &#39;false&#39;) 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return MultiPredictResponse
   */
  def multipredictimage(File: File, Id: String, NeedsPreprocessing: Boolean, DeploymentName: String, VersionName: String, ModelName: String): Option[MultiPredictResponse] = {
    val await = Try(Await.result(multipredictimageAsync(File, Id, NeedsPreprocessing, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the output from the network using the given image file using the /multipredict endpoint&#39;s method asynchronously
   * Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).
   *
   * @param File The image file to run the prediction on 
   * @param Id The id of the request (could be self generated) 
   * @param NeedsPreprocessing Whether or not the preprocessing is required (either &#39;true&#39; or &#39;false&#39;) 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(MultiPredictResponse)
   */
  def multipredictimageAsync(File: File, Id: String, NeedsPreprocessing: Boolean, DeploymentName: String, VersionName: String, ModelName: String): Future[MultiPredictResponse] = {
      helper.multipredictimage(File, Id, NeedsPreprocessing, DeploymentName, VersionName, ModelName)
  }

  /**
   * Run inference on the input array.
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Prediction
   */
  def predict(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Option[Prediction] = {
    val await = Try(Await.result(predictAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Run inference on the input array. asynchronously
   * 
   *
   * @param Body The input NDArray 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(Prediction)
   */
  def predictAsync(Body: Prediction, DeploymentName: String, VersionName: String, ModelName: String): Future[Prediction] = {
      helper.predict(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Run inference on the input array, using input image file from multipart form data.
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param Image The file to upload. (optional)
   * @return Prediction
   */
  def predictimage(DeploymentName: String, VersionName: String, ModelName: String, Image: Option[File] = None): Option[Prediction] = {
    val await = Try(Await.result(predictimageAsync(DeploymentName, VersionName, ModelName, Image), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Run inference on the input array, using input image file from multipart form data. asynchronously
   * 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @param Image The file to upload. (optional)
   * @return Future(Prediction)
   */
  def predictimageAsync(DeploymentName: String, VersionName: String, ModelName: String, Image: Option[File] = None): Future[Prediction] = {
      helper.predictimage(DeploymentName, VersionName, ModelName, Image)
  }

  /**
   * Preprocesses the input and run inference on it
   * 
   *
   * @param Body The input array 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Prediction
   */
  def predictwithpreprocess(Body: List[String], DeploymentName: String, VersionName: String, ModelName: String): Option[Prediction] = {
    val await = Try(Await.result(predictwithpreprocessAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Preprocesses the input and run inference on it asynchronously
   * 
   *
   * @param Body The input array 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(Prediction)
   */
  def predictwithpreprocessAsync(Body: List[String], DeploymentName: String, VersionName: String, ModelName: String): Future[Prediction] = {
      helper.predictwithpreprocess(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Preprocesses the input and run inference on it and returns it as a JsonArrayResponse
   * 
   *
   * @param Body The input array 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return JsonArrayResponse
   */
  def predictwithpreprocessjson(Body: List[String], DeploymentName: String, VersionName: String, ModelName: String): Option[JsonArrayResponse] = {
    val await = Try(Await.result(predictwithpreprocessjsonAsync(Body, DeploymentName, VersionName, ModelName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Preprocesses the input and run inference on it and returns it as a JsonArrayResponse asynchronously
   * 
   *
   * @param Body The input array 
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ModelName ID or name of the deployed model 
   * @return Future(JsonArrayResponse)
   */
  def predictwithpreprocessjsonAsync(Body: List[String], DeploymentName: String, VersionName: String, ModelName: String): Future[JsonArrayResponse] = {
      helper.predictwithpreprocessjson(Body, DeploymentName, VersionName, ModelName)
  }

  /**
   * Reimport a model to a previous deployed model in a deployment
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @param Body the deployment request 
   * @return ModelEntity
   */
  def reimportModel(DeploymentId: String, ModelId: String, Body: ImportModelRequest): Option[ModelEntity] = {
    val await = Try(Await.result(reimportModelAsync(DeploymentId, ModelId, Body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Reimport a model to a previous deployed model in a deployment asynchronously
   * 
   *
   * @param DeploymentId ID deployment group 
   * @param ModelId the id of the deployed model 
   * @param Body the deployment request 
   * @return Future(ModelEntity)
   */
  def reimportModelAsync(DeploymentId: String, ModelId: String, Body: ImportModelRequest): Future[ModelEntity] = {
      helper.reimportModel(DeploymentId, ModelId, Body)
  }

  /**
   * Takes a BatchCSVRecord and returns the transformed array as BatchCSVRecord
   * Takes a batch of SingleCSVRecord object and transforms it into the desired format
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param BatchCSVRecord The input batch of record arrays (optional)
   * @return BatchCSVRecord
   */
  def transformCsv(DeploymentName: String, VersionName: String, TransformName: String, BatchCSVRecord: Option[BatchCSVRecord] = None): Option[BatchCSVRecord] = {
    val await = Try(Await.result(transformCsvAsync(DeploymentName, VersionName, TransformName, BatchCSVRecord), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes a BatchCSVRecord and returns the transformed array as BatchCSVRecord asynchronously
   * Takes a batch of SingleCSVRecord object and transforms it into the desired format
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param BatchCSVRecord The input batch of record arrays (optional)
   * @return Future(BatchCSVRecord)
   */
  def transformCsvAsync(DeploymentName: String, VersionName: String, TransformName: String, BatchCSVRecord: Option[BatchCSVRecord] = None): Future[BatchCSVRecord] = {
      helper.transformCsv(DeploymentName, VersionName, TransformName, BatchCSVRecord)
  }

  /**
   * Takes a batch input arrays and transforms it
   * Takes a batch of SingleCSVRecord object and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param BatchCSVRecord The input batch of record arrays (optional)
   * @return Base64NDArrayBody
   */
  def transformarrayCsv(DeploymentName: String, VersionName: String, TransformName: String, BatchCSVRecord: Option[BatchCSVRecord] = None): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(transformarrayCsvAsync(DeploymentName, VersionName, TransformName, BatchCSVRecord), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes a batch input arrays and transforms it asynchronously
   * Takes a batch of SingleCSVRecord object and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param BatchCSVRecord The input batch of record arrays (optional)
   * @return Future(Base64NDArrayBody)
   */
  def transformarrayCsvAsync(DeploymentName: String, VersionName: String, TransformName: String, BatchCSVRecord: Option[BatchCSVRecord] = None): Future[Base64NDArrayBody] = {
      helper.transformarrayCsv(DeploymentName, VersionName, TransformName, BatchCSVRecord)
  }

  /**
   * Takes a batch of images uri and transforms it and returns Base64NDArrayBody
   * Takes a batch of SingleImageRecord object and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param BatchImageRecord The input batch of record arrays 
   * @return Base64NDArrayBody
   */
  def transformarrayImage(DeploymentName: String, VersionName: String, ImageTransformName: String, BatchImageRecord: BatchImageRecord): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(transformarrayImageAsync(DeploymentName, VersionName, ImageTransformName, BatchImageRecord), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes a batch of images uri and transforms it and returns Base64NDArrayBody asynchronously
   * Takes a batch of SingleImageRecord object and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param BatchImageRecord The input batch of record arrays 
   * @return Future(Base64NDArrayBody)
   */
  def transformarrayImageAsync(DeploymentName: String, VersionName: String, ImageTransformName: String, BatchImageRecord: BatchImageRecord): Future[Base64NDArrayBody] = {
      helper.transformarrayImage(DeploymentName, VersionName, ImageTransformName, BatchImageRecord)
  }

  /**
   * Takes multiple multipart image file to transform and returns Base64NDArrayBody
   * Takes multiple multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param Files The image files to upload 
   * @return Base64NDArrayBody
   */
  def transformimage(DeploymentName: String, VersionName: String, ImageTransformName: String, Files: List[Array[Byte]]): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(transformimageAsync(DeploymentName, VersionName, ImageTransformName, Files), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes multiple multipart image file to transform and returns Base64NDArrayBody asynchronously
   * Takes multiple multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param Files The image files to upload 
   * @return Future(Base64NDArrayBody)
   */
  def transformimageAsync(DeploymentName: String, VersionName: String, ImageTransformName: String, Files: List[Array[Byte]]): Future[Base64NDArrayBody] = {
      helper.transformimage(DeploymentName, VersionName, ImageTransformName, Files)
  }

  /**
   * Takes SingleCSVRecord as input and returns the transformed array as SingleCSVRecord
   * Takes a SingleCSVRecord object and transforms it into the desired format
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param SingleCSVRecord The input record array (optional)
   * @return SingleCSVRecord
   */
  def transformincrementalCsv(DeploymentName: String, VersionName: String, TransformName: String, SingleCSVRecord: Option[SingleCSVRecord] = None): Option[SingleCSVRecord] = {
    val await = Try(Await.result(transformincrementalCsvAsync(DeploymentName, VersionName, TransformName, SingleCSVRecord), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes SingleCSVRecord as input and returns the transformed array as SingleCSVRecord asynchronously
   * Takes a SingleCSVRecord object and transforms it into the desired format
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param SingleCSVRecord The input record array (optional)
   * @return Future(SingleCSVRecord)
   */
  def transformincrementalCsvAsync(DeploymentName: String, VersionName: String, TransformName: String, SingleCSVRecord: Option[SingleCSVRecord] = None): Future[SingleCSVRecord] = {
      helper.transformincrementalCsv(DeploymentName, VersionName, TransformName, SingleCSVRecord)
  }

  /**
   * Same as /transformincremental but returns Base64NDArrayBody
   * Takes a SingleCSVRecord object and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param SingleCSVRecord The input record array (optional)
   * @return Base64NDArrayBody
   */
  def transformincrementalarrayCsv(DeploymentName: String, VersionName: String, TransformName: String, SingleCSVRecord: Option[SingleCSVRecord] = None): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(transformincrementalarrayCsvAsync(DeploymentName, VersionName, TransformName, SingleCSVRecord), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Same as /transformincremental but returns Base64NDArrayBody asynchronously
   * Takes a SingleCSVRecord object and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param SingleCSVRecord The input record array (optional)
   * @return Future(Base64NDArrayBody)
   */
  def transformincrementalarrayCsvAsync(DeploymentName: String, VersionName: String, TransformName: String, SingleCSVRecord: Option[SingleCSVRecord] = None): Future[Base64NDArrayBody] = {
      helper.transformincrementalarrayCsv(DeploymentName, VersionName, TransformName, SingleCSVRecord)
  }

  /**
   * Takes SingleImageRecord to transform and returns Base64NDArrayBody
   * Takes a SingleImageRecord object and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param SingleImageRecord The input record array 
   * @return Base64NDArrayBody
   */
  def transformincrementalarrayImage(DeploymentName: String, VersionName: String, ImageTransformName: String, SingleImageRecord: SingleImageRecord): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(transformincrementalarrayImageAsync(DeploymentName, VersionName, ImageTransformName, SingleImageRecord), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes SingleImageRecord to transform and returns Base64NDArrayBody asynchronously
   * Takes a SingleImageRecord object and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param SingleImageRecord The input record array 
   * @return Future(Base64NDArrayBody)
   */
  def transformincrementalarrayImageAsync(DeploymentName: String, VersionName: String, ImageTransformName: String, SingleImageRecord: SingleImageRecord): Future[Base64NDArrayBody] = {
      helper.transformincrementalarrayImage(DeploymentName, VersionName, ImageTransformName, SingleImageRecord)
  }

  /**
   * Takes a single multipart image file to transform and returns Base64NDArrayBody
   * Takes a single multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param File The image file to upload 
   * @return Base64NDArrayBody
   */
  def transformincrementalimage(DeploymentName: String, VersionName: String, ImageTransformName: String, File: File): Option[Base64NDArrayBody] = {
    val await = Try(Await.result(transformincrementalimageAsync(DeploymentName, VersionName, ImageTransformName, File), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Takes a single multipart image file to transform and returns Base64NDArrayBody asynchronously
   * Takes a single multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param ImageTransformName ID or name of the deployed image transform 
   * @param File The image file to upload 
   * @return Future(Base64NDArrayBody)
   */
  def transformincrementalimageAsync(DeploymentName: String, VersionName: String, ImageTransformName: String, File: File): Future[Base64NDArrayBody] = {
      helper.transformincrementalimage(DeploymentName, VersionName, ImageTransformName, File)
  }

  /**
   * Gets the JSON string of the deployed transform process
   * Retrieves the JSON string of the deployed transform process 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @return TransformProcess
   */
  def transformprocessGet(DeploymentName: String, VersionName: String, TransformName: String): Option[TransformProcess] = {
    val await = Try(Await.result(transformprocessGetAsync(DeploymentName, VersionName, TransformName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Gets the JSON string of the deployed transform process asynchronously
   * Retrieves the JSON string of the deployed transform process 
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @return Future(TransformProcess)
   */
  def transformprocessGetAsync(DeploymentName: String, VersionName: String, TransformName: String): Future[TransformProcess] = {
      helper.transformprocessGet(DeploymentName, VersionName, TransformName)
  }

  /**
   * Sets the deployed transform process through the provided JSON string
   * Sets the transform process with the provided JSON string
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param TransformProcess The transform process to set (optional)
   * @return void
   */
  def transformprocessPost(DeploymentName: String, VersionName: String, TransformName: String, TransformProcess: Option[TransformProcess] = None) = {
    val await = Try(Await.result(transformprocessPostAsync(DeploymentName, VersionName, TransformName, TransformProcess), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Sets the deployed transform process through the provided JSON string asynchronously
   * Sets the transform process with the provided JSON string
   *
   * @param DeploymentName Name of the deployment group 
   * @param VersionName Version name of the endpoint. The default value is \&quot;default\&quot; 
   * @param TransformName ID or name of the deployed transform 
   * @param TransformProcess The transform process to set (optional)
   * @return Future(void)
   */
  def transformprocessPostAsync(DeploymentName: String, VersionName: String, TransformName: String, TransformProcess: Option[TransformProcess] = None) = {
      helper.transformprocessPost(DeploymentName, VersionName, TransformName, TransformProcess)
  }

  /**
   * Updates the best model for an experiment
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param UpdateBestModel Model encapsulating the experiment id to update and the best model id. 
   * @return ExperimentEntity
   */
  def updateBestModelForExperiment(ModelHistoryServerId: String, UpdateBestModel: UpdateBestModel): Option[ExperimentEntity] = {
    val await = Try(Await.result(updateBestModelForExperimentAsync(ModelHistoryServerId, UpdateBestModel), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Updates the best model for an experiment asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param UpdateBestModel Model encapsulating the experiment id to update and the best model id. 
   * @return Future(ExperimentEntity)
   */
  def updateBestModelForExperimentAsync(ModelHistoryServerId: String, UpdateBestModel: UpdateBestModel): Future[ExperimentEntity] = {
      helper.updateBestModelForExperiment(ModelHistoryServerId, UpdateBestModel)
  }

  /**
   * Updates an experiment, given an experiment entity
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to update 
   * @param ExperimentEntity The experiment entity to update with 
   * @return ExperimentEntity
   */
  def updateExperiment(ModelHistoryServerId: String, ExperimentID: String, ExperimentEntity: ExperimentEntity): Option[ExperimentEntity] = {
    val await = Try(Await.result(updateExperimentAsync(ModelHistoryServerId, ExperimentID, ExperimentEntity), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Updates an experiment, given an experiment entity asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ExperimentID the GUID of the experiment to update 
   * @param ExperimentEntity The experiment entity to update with 
   * @return Future(ExperimentEntity)
   */
  def updateExperimentAsync(ModelHistoryServerId: String, ExperimentID: String, ExperimentEntity: ExperimentEntity): Future[ExperimentEntity] = {
      helper.updateExperiment(ModelHistoryServerId, ExperimentID, ExperimentEntity)
  }

  /**
   * Update a model history / workspace
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to update 
   * @param UpdateModelHistoryRequest The model history request object 
   * @return ModelHistoryEntity
   */
  def updateModelHistory(ModelHistoryServerId: String, ModelHistoryID: String, UpdateModelHistoryRequest: AddModelHistoryRequest): Option[ModelHistoryEntity] = {
    val await = Try(Await.result(updateModelHistoryAsync(ModelHistoryServerId, ModelHistoryID, UpdateModelHistoryRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update a model history / workspace asynchronously
   * 
   *
   * @param ModelHistoryServerId Process GUID of the model history server. Run &#x60;$SKIL_HOME/sbin/skil services&#x60; in a console to find out the model history server GUID. 
   * @param ModelHistoryID the GUID of the model history / workspace to update 
   * @param UpdateModelHistoryRequest The model history request object 
   * @return Future(ModelHistoryEntity)
   */
  def updateModelHistoryAsync(ModelHistoryServerId: String, ModelHistoryID: String, UpdateModelHistoryRequest: AddModelHistoryRequest): Future[ModelHistoryEntity] = {
      helper.updateModelHistory(ModelHistoryServerId, ModelHistoryID, UpdateModelHistoryRequest)
  }

  /**
   * Upload a model file to SKIL for import.
   * 
   *
   * @param File The file to upload. (optional)
   * @return FileUploadList
   */
  def upload(File: Option[File] = None): Option[FileUploadList] = {
    val await = Try(Await.result(uploadAsync(File), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Upload a model file to SKIL for import. asynchronously
   * 
   *
   * @param File The file to upload. (optional)
   * @return Future(FileUploadList)
   */
  def uploadAsync(File: Option[File] = None): Future[FileUploadList] = {
      helper.upload(File)
  }

}

class DefaultApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def addEvaluationResult(ModelHistoryServerId: String,
    EvaluationResultsEntity: EvaluationResultsEntity)(implicit reader: ClientResponseReader[EvaluationResultsEntity], writer: RequestWriter[EvaluationResultsEntity]): Future[EvaluationResultsEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revisions/evaluations/")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addEvaluationResult")

    if (EvaluationResultsEntity == null) throw new Exception("Missing required parameter 'EvaluationResultsEntity' when calling DefaultApi->addEvaluationResult")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(EvaluationResultsEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addExampleForBatch(ModelHistoryServerId: String,
    AddExampleRequest: AddExampleRequest)(implicit reader: ClientResponseReader[AddExampleRequest], writer: RequestWriter[AddExampleRequest]): Future[AddExampleRequest] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/exampleForBatch")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addExampleForBatch")

    if (AddExampleRequest == null) throw new Exception("Missing required parameter 'AddExampleRequest' when calling DefaultApi->addExampleForBatch")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(AddExampleRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addExampleToMinibatch(ModelHistoryServerId: String,
    ExampleEntity: ExampleEntity)(implicit reader: ClientResponseReader[ExampleEntity], writer: RequestWriter[ExampleEntity]): Future[ExampleEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/example")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addExampleToMinibatch")

    if (ExampleEntity == null) throw new Exception("Missing required parameter 'ExampleEntity' when calling DefaultApi->addExampleToMinibatch")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ExampleEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addExperiment(ModelHistoryServerId: String,
    ExperimentEntity: ExperimentEntity)(implicit reader: ClientResponseReader[ExperimentEntity], writer: RequestWriter[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addExperiment")

    if (ExperimentEntity == null) throw new Exception("Missing required parameter 'ExperimentEntity' when calling DefaultApi->addExperiment")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ExperimentEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addMinibatch(ModelHistoryServerId: String,
    MinibatchEntity: MinibatchEntity)(implicit reader: ClientResponseReader[MinibatchEntity], writer: RequestWriter[MinibatchEntity]): Future[MinibatchEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/minibatch")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addMinibatch")

    if (MinibatchEntity == null) throw new Exception("Missing required parameter 'MinibatchEntity' when calling DefaultApi->addMinibatch")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(MinibatchEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addModelFeedback(ModelHistoryServerId: String,
    ModelFeedBackRequest: ModelFeedBackRequest)(implicit reader: ClientResponseReader[ModelFeedBackRequest], writer: RequestWriter[ModelFeedBackRequest]): Future[ModelFeedBackRequest] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/feedback")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addModelFeedback")

    if (ModelFeedBackRequest == null) throw new Exception("Missing required parameter 'ModelFeedBackRequest' when calling DefaultApi->addModelFeedback")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ModelFeedBackRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addModelHistory(ModelHistoryServerId: String,
    AddModelHistoryRequest: AddModelHistoryRequest)(implicit reader: ClientResponseReader[ModelHistoryEntity], writer: RequestWriter[AddModelHistoryRequest]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/modelhistory")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addModelHistory")

    if (AddModelHistoryRequest == null) throw new Exception("Missing required parameter 'AddModelHistoryRequest' when calling DefaultApi->addModelHistory")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(AddModelHistoryRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addModelInstance(ModelHistoryServerId: String,
    ModelInstanceEntity: ModelInstanceEntity)(implicit reader: ClientResponseReader[ModelInstanceEntity], writer: RequestWriter[ModelInstanceEntity]): Future[ModelInstanceEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->addModelInstance")

    if (ModelInstanceEntity == null) throw new Exception("Missing required parameter 'ModelInstanceEntity' when calling DefaultApi->addModelInstance")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ModelInstanceEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def aggregateModelResults(ModelHistoryServerId: String,
    AggregatePrediction: AggregatePrediction)(implicit reader: ClientResponseReader[EvaluationResultsEntity], writer: RequestWriter[AggregatePrediction]): Future[EvaluationResultsEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/aggregateresults")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->aggregateModelResults")

    if (AggregatePrediction == null) throw new Exception("Missing required parameter 'AggregatePrediction' when calling DefaultApi->aggregateModelResults")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(AggregatePrediction))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def classify(Body: Prediction,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[ClassificationResult], writer: RequestWriter[Prediction]): Future[ClassificationResult] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/classify")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->classify")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->classify")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->classify")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->classify")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def classifyarray(Body: Prediction,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[Base64NDArrayBody], writer: RequestWriter[Prediction]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyarray")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->classifyarray")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->classifyarray")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->classifyarray")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->classifyarray")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def classifyimage(DeploymentName: String,
    VersionName: String,
    ModelName: String,
    Image: Option[File] = None
    )(implicit reader: ClientResponseReader[ClassificationResult]): Future[ClassificationResult] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyimage")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->classifyimage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->classifyimage")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->classifyimage")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createModelHistory(ModelHistoryServerId: String,
    ModelHistoryEntity: ModelHistoryEntity)(implicit reader: ClientResponseReader[ModelHistoryEntity], writer: RequestWriter[ModelHistoryEntity]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revisions")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->createModelHistory")

    if (ModelHistoryEntity == null) throw new Exception("Missing required parameter 'ModelHistoryEntity' when calling DefaultApi->createModelHistory")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(ModelHistoryEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteExperiment(ModelHistoryServerId: String,
    ExperimentID: String)(implicit reader: ClientResponseReader[InlineResponse200]): Future[InlineResponse200] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->deleteExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling DefaultApi->deleteExperiment")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteModel(DeploymentId: String,
    ModelId: String)(implicit reader: ClientResponseReader[InlineResponse200]): Future[InlineResponse200] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}/model/{modelId}")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString)
      replaceAll("\\{" + "modelId" + "\\}", ModelId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->deleteModel")

    if (ModelId == null) throw new Exception("Missing required parameter 'ModelId' when calling DefaultApi->deleteModel")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String)(implicit reader: ClientResponseReader[InlineResponse200]): Future[InlineResponse200] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->deleteModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling DefaultApi->deleteModelHistory")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteModelInstance(ModelHistoryServerId: String,
    ModelInstanceID: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/{modelInstanceID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelInstanceID" + "\\}", ModelInstanceID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->deleteModelInstance")

    if (ModelInstanceID == null) throw new Exception("Missing required parameter 'ModelInstanceID' when calling DefaultApi->deleteModelInstance")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deployModel(DeploymentId: String,
    Body: ImportModelRequest)(implicit reader: ClientResponseReader[ModelEntity], writer: RequestWriter[ImportModelRequest]): Future[ModelEntity] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}/model")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->deployModel")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->deployModel")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deploymentCreate(Body: CreateDeploymentRequest)(implicit reader: ClientResponseReader[DeploymentResponse], writer: RequestWriter[CreateDeploymentRequest]): Future[DeploymentResponse] = {
    // create path and map variables
    val path = (addFmt("/deployment"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->deploymentCreate")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deploymentDelete(DeploymentId: String)(implicit reader: ClientResponseReader[InlineResponse200]): Future[InlineResponse200] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->deploymentDelete")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deploymentGet(DeploymentId: String)(implicit reader: ClientResponseReader[DeploymentResponse]): Future[DeploymentResponse] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->deploymentGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deployments()(implicit reader: ClientResponseReader[List[DeploymentResponse]]): Future[List[DeploymentResponse]] = {
    // create path and map variables
    val path = (addFmt("/deployments"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def detectobjects(Id: String,
    NeedsPreprocessing: Boolean,
    Threshold: Float,
    ImageFile: File,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[DetectionResult]): Future[DetectionResult] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/detectobjects")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Id == null) throw new Exception("Missing required parameter 'Id' when calling DefaultApi->detectobjects")

    if (ImageFile == null) throw new Exception("Missing required parameter 'ImageFile' when calling DefaultApi->detectobjects")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->detectobjects")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->detectobjects")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->detectobjects")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getBestModelAmongModelIds(ModelHistoryServerId: String,
    BestModel: BestModel)(implicit reader: ClientResponseReader[ModelInstanceEntity], writer: RequestWriter[BestModel]): Future[ModelInstanceEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/best")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getBestModelAmongModelIds")

    if (BestModel == null) throw new Exception("Missing required parameter 'BestModel' when calling DefaultApi->getBestModelAmongModelIds")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(BestModel))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEvaluationForModelID(ModelHistoryServerId: String,
    ModelInstanceID: String)(implicit reader: ClientResponseReader[List[EvaluationResultsEntity]]): Future[List[EvaluationResultsEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revisions/evaluations/{modelInstanceID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelInstanceID" + "\\}", ModelInstanceID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getEvaluationForModelID")

    if (ModelInstanceID == null) throw new Exception("Missing required parameter 'ModelInstanceID' when calling DefaultApi->getEvaluationForModelID")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getExamplesForMinibatch(ModelHistoryServerId: String,
    MinibatchId: String)(implicit reader: ClientResponseReader[List[ExampleEntity]]): Future[List[ExampleEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/example/{minibatchId}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "minibatchId" + "\\}", MinibatchId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getExamplesForMinibatch")

    if (MinibatchId == null) throw new Exception("Missing required parameter 'MinibatchId' when calling DefaultApi->getExamplesForMinibatch")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getExperiment(ModelHistoryServerId: String,
    ExperimentID: String)(implicit reader: ClientResponseReader[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling DefaultApi->getExperiment")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getExperimentsForModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String)(implicit reader: ClientResponseReader[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiments/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getExperimentsForModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling DefaultApi->getExperimentsForModelHistory")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getMinibatch(ModelHistoryServerId: String,
    MinibatchId: String)(implicit reader: ClientResponseReader[MinibatchEntity]): Future[MinibatchEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/minibatch/{minibatchId}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "minibatchId" + "\\}", MinibatchId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getMinibatch")

    if (MinibatchId == null) throw new Exception("Missing required parameter 'MinibatchId' when calling DefaultApi->getMinibatch")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String)(implicit reader: ClientResponseReader[ModelHistoryEntity]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/revision/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling DefaultApi->getModelHistory")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getModelInstance(ModelHistoryServerId: String,
    ModelInstanceID: String)(implicit reader: ClientResponseReader[ModelInstanceEntity]): Future[ModelInstanceEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/model/{modelInstanceID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelInstanceID" + "\\}", ModelInstanceID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getModelInstance")

    if (ModelInstanceID == null) throw new Exception("Missing required parameter 'ModelInstanceID' when calling DefaultApi->getModelInstance")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getModelsForExperiment(ModelHistoryServerId: String,
    ExperimentID: String)(implicit reader: ClientResponseReader[List[ModelInstanceEntity]]): Future[List[ModelInstanceEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}/models")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->getModelsForExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling DefaultApi->getModelsForExperiment")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def imagetransformprocessGet(DeploymentName: String,
    VersionName: String,
    ImageTransformName: String)(implicit reader: ClientResponseReader[ImageTransformProcess]): Future[ImageTransformProcess] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformprocess")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "imageTransformName" + "\\}", ImageTransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->imagetransformprocessGet")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->imagetransformprocessGet")

    if (ImageTransformName == null) throw new Exception("Missing required parameter 'ImageTransformName' when calling DefaultApi->imagetransformprocessGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def imagetransformprocessPost(DeploymentName: String,
    VersionName: String,
    ImageTransformName: String,
    Body: ImageTransformProcess)(implicit reader: ClientResponseReader[ImageTransformProcess], writer: RequestWriter[ImageTransformProcess]): Future[ImageTransformProcess] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformprocess")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "imageTransformName" + "\\}", ImageTransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->imagetransformprocessPost")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->imagetransformprocessPost")

    if (ImageTransformName == null) throw new Exception("Missing required parameter 'ImageTransformName' when calling DefaultApi->imagetransformprocessPost")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->imagetransformprocessPost")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def jsonarray(Body: Prediction,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[JsonArrayResponse], writer: RequestWriter[Prediction]): Future[JsonArrayResponse] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/jsonarray")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->jsonarray")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->jsonarray")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->jsonarray")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->jsonarray")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def knn(DeploymentName: String,
    VersionName: String,
    KnnName: String,
    Body: NearestNeighborRequest)(implicit reader: ClientResponseReader[NearestNeighborsResults], writer: RequestWriter[NearestNeighborRequest]): Future[NearestNeighborsResults] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knn")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "knnName" + "\\}", KnnName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->knn")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->knn")

    if (KnnName == null) throw new Exception("Missing required parameter 'KnnName' when calling DefaultApi->knn")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->knn")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def knnnew(DeploymentName: String,
    VersionName: String,
    KnnName: String,
    Body: Base64NDArrayBodyKNN)(implicit reader: ClientResponseReader[NearestNeighborsResults], writer: RequestWriter[Base64NDArrayBodyKNN]): Future[NearestNeighborsResults] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knnnew")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "knnName" + "\\}", KnnName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->knnnew")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->knnnew")

    if (KnnName == null) throw new Exception("Missing required parameter 'KnnName' when calling DefaultApi->knnnew")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->knnnew")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listAllExperiments()(implicit reader: ClientResponseReader[List[ExperimentEntity]]): Future[List[ExperimentEntity]] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiments"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def logfilepath(DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/logfilepath")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->logfilepath")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->logfilepath")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->logfilepath")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def login(Credentials: Credentials)(implicit reader: ClientResponseReader[Token], writer: RequestWriter[Credentials]): Future[Token] = {
    // create path and map variables
    val path = (addFmt("/login"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Credentials == null) throw new Exception("Missing required parameter 'Credentials' when calling DefaultApi->login")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Credentials))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def logs(Body: LogRequest,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[LogBatch], writer: RequestWriter[LogRequest]): Future[LogBatch] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/logs")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->logs")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->logs")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->logs")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->logs")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def metaGet(DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[MetaData]): Future[MetaData] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->metaGet")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->metaGet")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->metaGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def metaPost(Body: MetaData,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[MetaData], writer: RequestWriter[MetaData]): Future[MetaData] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->metaPost")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->metaPost")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->metaPost")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->metaPost")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def modelStateChange(DeploymentId: String,
    ModelId: String,
    Body: SetState)(implicit reader: ClientResponseReader[ModelEntity], writer: RequestWriter[SetState]): Future[ModelEntity] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}/model/{modelId}/state")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString)
      replaceAll("\\{" + "modelId" + "\\}", ModelId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->modelStateChange")

    if (ModelId == null) throw new Exception("Missing required parameter 'ModelId' when calling DefaultApi->modelStateChange")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->modelStateChange")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def models(DeploymentId: String)(implicit reader: ClientResponseReader[List[ModelEntity]]): Future[List[ModelEntity]] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}/models")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->models")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def modelset(DeploymentName: String,
    VersionName: String,
    ModelName: String,
    File: Option[File] = None
    )(implicit reader: ClientResponseReader[ModelStatus]): Future[ModelStatus] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelset")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->modelset")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->modelset")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->modelset")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def modelupdate(DeploymentName: String,
    VersionName: String,
    ModelName: String,
    File: Option[File] = None
    )(implicit reader: ClientResponseReader[ModelStatus]): Future[ModelStatus] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelupdate")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->modelupdate")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->modelupdate")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->modelupdate")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def multiclassify(Body: Prediction,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[MultiClassClassificationResult], writer: RequestWriter[Prediction]): Future[MultiClassClassificationResult] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/multiclassify")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->multiclassify")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->multiclassify")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->multiclassify")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->multiclassify")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def multipredict(Body: MultiPredictRequest,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[MultiPredictResponse], writer: RequestWriter[MultiPredictRequest]): Future[MultiPredictResponse] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredict")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->multipredict")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->multipredict")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->multipredict")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->multipredict")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def multipredictimage(File: File,
    Id: String,
    NeedsPreprocessing: Boolean,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[MultiPredictResponse]): Future[MultiPredictResponse] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredictimage")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (File == null) throw new Exception("Missing required parameter 'File' when calling DefaultApi->multipredictimage")
    if (Id == null) throw new Exception("Missing required parameter 'Id' when calling DefaultApi->multipredictimage")

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->multipredictimage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->multipredictimage")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->multipredictimage")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def predict(Body: Prediction,
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[Prediction], writer: RequestWriter[Prediction]): Future[Prediction] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/predict")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->predict")
    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->predict")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->predict")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->predict")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def predictimage(DeploymentName: String,
    VersionName: String,
    ModelName: String,
    Image: Option[File] = None
    )(implicit reader: ClientResponseReader[Prediction]): Future[Prediction] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictimage")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->predictimage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->predictimage")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->predictimage")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def predictwithpreprocess(Body: List[String],
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[Prediction], writer: RequestWriter[List[String]]): Future[Prediction] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocess")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->predictwithpreprocess")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->predictwithpreprocess")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->predictwithpreprocess")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def predictwithpreprocessjson(Body: List[String],
    DeploymentName: String,
    VersionName: String,
    ModelName: String)(implicit reader: ClientResponseReader[JsonArrayResponse], writer: RequestWriter[List[String]]): Future[JsonArrayResponse] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocessjson")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "modelName" + "\\}", ModelName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->predictwithpreprocessjson")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->predictwithpreprocessjson")

    if (ModelName == null) throw new Exception("Missing required parameter 'ModelName' when calling DefaultApi->predictwithpreprocessjson")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def reimportModel(DeploymentId: String,
    ModelId: String,
    Body: ImportModelRequest)(implicit reader: ClientResponseReader[ModelEntity], writer: RequestWriter[ImportModelRequest]): Future[ModelEntity] = {
    // create path and map variables
    val path = (addFmt("/deployment/{deploymentId}/model/{modelId}")
      replaceAll("\\{" + "deploymentId" + "\\}", DeploymentId.toString)
      replaceAll("\\{" + "modelId" + "\\}", ModelId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentId == null) throw new Exception("Missing required parameter 'DeploymentId' when calling DefaultApi->reimportModel")

    if (ModelId == null) throw new Exception("Missing required parameter 'ModelId' when calling DefaultApi->reimportModel")

    if (Body == null) throw new Exception("Missing required parameter 'Body' when calling DefaultApi->reimportModel")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(Body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformCsv(DeploymentName: String,
    VersionName: String,
    TransformName: String,
    BatchCSVRecord: Option[BatchCSVRecord] = None
    )(implicit reader: ClientResponseReader[BatchCSVRecord], writer: RequestWriter[Option[BatchCSVRecord]]): Future[BatchCSVRecord] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transform")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformCsv")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformCsv")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformCsv")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(BatchCSVRecord))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformarrayCsv(DeploymentName: String,
    VersionName: String,
    TransformName: String,
    BatchCSVRecord: Option[BatchCSVRecord] = None
    )(implicit reader: ClientResponseReader[Base64NDArrayBody], writer: RequestWriter[Option[BatchCSVRecord]]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformarray")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformarrayCsv")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformarrayCsv")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformarrayCsv")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(BatchCSVRecord))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformarrayImage(DeploymentName: String,
    VersionName: String,
    ImageTransformName: String,
    BatchImageRecord: BatchImageRecord)(implicit reader: ClientResponseReader[Base64NDArrayBody], writer: RequestWriter[BatchImageRecord]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformarray")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "imageTransformName" + "\\}", ImageTransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformarrayImage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformarrayImage")

    if (ImageTransformName == null) throw new Exception("Missing required parameter 'ImageTransformName' when calling DefaultApi->transformarrayImage")

    if (BatchImageRecord == null) throw new Exception("Missing required parameter 'BatchImageRecord' when calling DefaultApi->transformarrayImage")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(BatchImageRecord))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformimage(DeploymentName: String,
    VersionName: String,
    ImageTransformName: String,
    Files: List[Array[Byte]])(implicit reader: ClientResponseReader[Base64NDArrayBody]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformimage")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "imageTransformName" + "\\}", ImageTransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformimage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformimage")

    if (ImageTransformName == null) throw new Exception("Missing required parameter 'ImageTransformName' when calling DefaultApi->transformimage")

    if (Files == null) throw new Exception("Missing required parameter 'Files' when calling DefaultApi->transformimage")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformincrementalCsv(DeploymentName: String,
    VersionName: String,
    TransformName: String,
    SingleCSVRecord: Option[SingleCSVRecord] = None
    )(implicit reader: ClientResponseReader[SingleCSVRecord], writer: RequestWriter[Option[SingleCSVRecord]]): Future[SingleCSVRecord] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincremental")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformincrementalCsv")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformincrementalCsv")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformincrementalCsv")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(SingleCSVRecord))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformincrementalarrayCsv(DeploymentName: String,
    VersionName: String,
    TransformName: String,
    SingleCSVRecord: Option[SingleCSVRecord] = None
    )(implicit reader: ClientResponseReader[Base64NDArrayBody], writer: RequestWriter[Option[SingleCSVRecord]]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincrementalarray")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformincrementalarrayCsv")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformincrementalarrayCsv")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformincrementalarrayCsv")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(SingleCSVRecord))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformincrementalarrayImage(DeploymentName: String,
    VersionName: String,
    ImageTransformName: String,
    SingleImageRecord: SingleImageRecord)(implicit reader: ClientResponseReader[Base64NDArrayBody], writer: RequestWriter[SingleImageRecord]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformincrementalarray")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "imageTransformName" + "\\}", ImageTransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformincrementalarrayImage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformincrementalarrayImage")

    if (ImageTransformName == null) throw new Exception("Missing required parameter 'ImageTransformName' when calling DefaultApi->transformincrementalarrayImage")

    if (SingleImageRecord == null) throw new Exception("Missing required parameter 'SingleImageRecord' when calling DefaultApi->transformincrementalarrayImage")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(SingleImageRecord))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformincrementalimage(DeploymentName: String,
    VersionName: String,
    ImageTransformName: String,
    File: File)(implicit reader: ClientResponseReader[Base64NDArrayBody]): Future[Base64NDArrayBody] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformincrementalimage")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "imageTransformName" + "\\}", ImageTransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformincrementalimage")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformincrementalimage")

    if (ImageTransformName == null) throw new Exception("Missing required parameter 'ImageTransformName' when calling DefaultApi->transformincrementalimage")

    if (File == null) throw new Exception("Missing required parameter 'File' when calling DefaultApi->transformincrementalimage")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformprocessGet(DeploymentName: String,
    VersionName: String,
    TransformName: String)(implicit reader: ClientResponseReader[TransformProcess]): Future[TransformProcess] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformprocessGet")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformprocessGet")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformprocessGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def transformprocessPost(DeploymentName: String,
    VersionName: String,
    TransformName: String,
    TransformProcess: Option[TransformProcess] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[TransformProcess]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess")
      replaceAll("\\{" + "deploymentName" + "\\}", DeploymentName.toString)
      replaceAll("\\{" + "versionName" + "\\}", VersionName.toString)
      replaceAll("\\{" + "transformName" + "\\}", TransformName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (DeploymentName == null) throw new Exception("Missing required parameter 'DeploymentName' when calling DefaultApi->transformprocessPost")

    if (VersionName == null) throw new Exception("Missing required parameter 'VersionName' when calling DefaultApi->transformprocessPost")

    if (TransformName == null) throw new Exception("Missing required parameter 'TransformName' when calling DefaultApi->transformprocessPost")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(TransformProcess))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateBestModelForExperiment(ModelHistoryServerId: String,
    UpdateBestModel: UpdateBestModel)(implicit reader: ClientResponseReader[ExperimentEntity], writer: RequestWriter[UpdateBestModel]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/best")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->updateBestModelForExperiment")

    if (UpdateBestModel == null) throw new Exception("Missing required parameter 'UpdateBestModel' when calling DefaultApi->updateBestModelForExperiment")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(UpdateBestModel))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateExperiment(ModelHistoryServerId: String,
    ExperimentID: String,
    ExperimentEntity: ExperimentEntity)(implicit reader: ClientResponseReader[ExperimentEntity], writer: RequestWriter[ExperimentEntity]): Future[ExperimentEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/experiment/{experimentID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "experimentID" + "\\}", ExperimentID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->updateExperiment")

    if (ExperimentID == null) throw new Exception("Missing required parameter 'ExperimentID' when calling DefaultApi->updateExperiment")

    if (ExperimentEntity == null) throw new Exception("Missing required parameter 'ExperimentEntity' when calling DefaultApi->updateExperiment")

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(ExperimentEntity))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateModelHistory(ModelHistoryServerId: String,
    ModelHistoryID: String,
    UpdateModelHistoryRequest: AddModelHistoryRequest)(implicit reader: ClientResponseReader[ModelHistoryEntity], writer: RequestWriter[AddModelHistoryRequest]): Future[ModelHistoryEntity] = {
    // create path and map variables
    val path = (addFmt("/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}")
      replaceAll("\\{" + "modelHistoryServerId" + "\\}", ModelHistoryServerId.toString)
      replaceAll("\\{" + "modelHistoryID" + "\\}", ModelHistoryID.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (ModelHistoryServerId == null) throw new Exception("Missing required parameter 'ModelHistoryServerId' when calling DefaultApi->updateModelHistory")

    if (ModelHistoryID == null) throw new Exception("Missing required parameter 'ModelHistoryID' when calling DefaultApi->updateModelHistory")

    if (UpdateModelHistoryRequest == null) throw new Exception("Missing required parameter 'UpdateModelHistoryRequest' when calling DefaultApi->updateModelHistory")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(UpdateModelHistoryRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def upload(File: Option[File] = None
    )(implicit reader: ClientResponseReader[FileUploadList]): Future[FileUploadList] = {
    // create path and map variables
    val path = (addFmt("/api/upload/model"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
