//
// DefaultAPI.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation
import Alamofire


open class DefaultAPI: APIBase {
    /**
     Use the deployed model to classify the input
     - parameter body: (body) The input NDArray 
     - parameter modelURI: (path) The URI of the model 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func classify(body: Prediction, modelURI: String, completion: @escaping ((_ data: ClassificationResult?, _ error: ErrorResponse?) -> Void)) {
        classifyWithRequestBuilder(body: body, modelURI: modelURI).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Use the deployed model to classify the input
     - POST /endpoints/{modelURI}/classify
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "minibatchId" : "minibatchId",
  "results" : [ 0, 0 ],
  "probabilities" : [ 0.452, 0.452 ]
}}]
     - parameter body: (body) The input NDArray 
     - parameter modelURI: (path) The URI of the model 
     - returns: RequestBuilder<ClassificationResult> 
     */
    open class func classifyWithRequestBuilder(body: Prediction, modelURI: String) -> RequestBuilder<ClassificationResult> {
        var path = "/endpoints/{modelURI}/classify"
        let modelURIPreEscape = "\(modelURI)"
        let modelURIPostEscape = modelURIPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelURI}", with: modelURIPostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let parameters = body.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<ClassificationResult>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Same as /classify but returns the output as Base64NDArrayBody
     - parameter body: (body) The input NDArray 
     - parameter modelURI: (path) The URI of the model 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func classifyarray(body: Prediction, modelURI: String, completion: @escaping ((_ data: Base64NDArrayBody?, _ error: ErrorResponse?) -> Void)) {
        classifyarrayWithRequestBuilder(body: body, modelURI: modelURI).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Same as /classify but returns the output as Base64NDArrayBody
     - POST /endpoints/{modelURI}/classifyarray
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "ndarray" : "ndarray"
}}]
     - parameter body: (body) The input NDArray 
     - parameter modelURI: (path) The URI of the model 
     - returns: RequestBuilder<Base64NDArrayBody> 
     */
    open class func classifyarrayWithRequestBuilder(body: Prediction, modelURI: String) -> RequestBuilder<Base64NDArrayBody> {
        var path = "/endpoints/{modelURI}/classifyarray"
        let modelURIPreEscape = "\(modelURI)"
        let modelURIPostEscape = modelURIPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelURI}", with: modelURIPostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let parameters = body.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Base64NDArrayBody>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Use the deployed model to classify the input, using input image file from multipart form data.
     - parameter modelURI: (path) The URI of the model 
     - parameter image: (form) The file to upload. (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func classifyimage(modelURI: String, image: URL? = nil, completion: @escaping ((_ data: ClassificationResult?, _ error: ErrorResponse?) -> Void)) {
        classifyimageWithRequestBuilder(modelURI: modelURI, image: image).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Use the deployed model to classify the input, using input image file from multipart form data.
     - POST /endpoints/{modelURI}/classifyimage
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "minibatchId" : "minibatchId",
  "results" : [ 0, 0 ],
  "probabilities" : [ 0.452, 0.452 ]
}}]
     - parameter modelURI: (path) The URI of the model 
     - parameter image: (form) The file to upload. (optional)
     - returns: RequestBuilder<ClassificationResult> 
     */
    open class func classifyimageWithRequestBuilder(modelURI: String, image: URL? = nil) -> RequestBuilder<ClassificationResult> {
        var path = "/endpoints/{modelURI}/classifyimage"
        let modelURIPreEscape = "\(modelURI)"
        let modelURIPostEscape = modelURIPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelURI}", with: modelURIPostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let formParams: [String:Any?] = [
            "image": image
        ]

        let nonNullParameters = APIHelper.rejectNil(formParams)
        let parameters = APIHelper.convertBoolToString(nonNullParameters)

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<ClassificationResult>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Deploy a model in a deployment group.
     - parameter deploymentId: (path) ID deployment group 
     - parameter body: (body) the deployment request 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func deployModel(deploymentId: String, body: DeployModel, completion: @escaping ((_ data: Any?, _ error: ErrorResponse?) -> Void)) {
        deployModelWithRequestBuilder(deploymentId: deploymentId, body: body).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Deploy a model in a deployment group.
     - POST /deployment/{deploymentId}/model
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example="{}"}]
     - parameter deploymentId: (path) ID deployment group 
     - parameter body: (body) the deployment request 
     - returns: RequestBuilder<Any> 
     */
    open class func deployModelWithRequestBuilder(deploymentId: String, body: DeployModel) -> RequestBuilder<Any> {
        var path = "/deployment/{deploymentId}/model"
        let deploymentIdPreEscape = "\(deploymentId)"
        let deploymentIdPostEscape = deploymentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{deploymentId}", with: deploymentIdPostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let parameters = body.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Any>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Create a new deployment group.
     - parameter body: (body) the deployment request 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func deploymentCreate(body: NewDeployment, completion: @escaping ((_ data: Deployment?, _ error: ErrorResponse?) -> Void)) {
        deploymentCreateWithRequestBuilder(body: body).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Create a new deployment group.
     - POST /deployment
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "name" : "name",
  "id" : "id",
  "body" : {
    "models" : [ "{}", "{}" ],
    "transforms" : [ "{}", "{}" ],
    "knn" : [ "{}", "{}" ]
  },
  "deploymentSlug" : "deploymentSlug",
  "status" : "status"
}}]
     - parameter body: (body) the deployment request 
     - returns: RequestBuilder<Deployment> 
     */
    open class func deploymentCreateWithRequestBuilder(body: NewDeployment) -> RequestBuilder<Deployment> {
        let path = "/deployment"
        let URLString = SkilClientAPI.basePath + path
        let parameters = body.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Deployment>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Run inference on the input and returns it as a JsonArrayResponse
     - parameter body: (body) The input NDArray 
     - parameter modelURI: (path) The URI of the model 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func jsonarray(body: Prediction, modelURI: String, completion: @escaping ((_ data: JsonArrayResponse?, _ error: ErrorResponse?) -> Void)) {
        jsonarrayWithRequestBuilder(body: body, modelURI: modelURI).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Run inference on the input and returns it as a JsonArrayResponse
     - POST /endpoints/{modelURI}/jsonarray
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "array" : {
    "array" : "array"
  }
}}]
     - parameter body: (body) The input NDArray 
     - parameter modelURI: (path) The URI of the model 
     - returns: RequestBuilder<JsonArrayResponse> 
     */
    open class func jsonarrayWithRequestBuilder(body: Prediction, modelURI: String) -> RequestBuilder<JsonArrayResponse> {
        var path = "/endpoints/{modelURI}/jsonarray"
        let modelURIPreEscape = "\(modelURI)"
        let modelURIPostEscape = modelURIPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelURI}", with: modelURIPostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let parameters = body.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<JsonArrayResponse>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Get logs file path
     - parameter deploymentName: (path) Name of the deployment group 
     - parameter modelName: (path) ID or name of the deployed model 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func logfilepath(deploymentName: String, modelName: String, completion: @escaping ((_ data: String?, _ error: ErrorResponse?) -> Void)) {
        logfilepathWithRequestBuilder(deploymentName: deploymentName, modelName: modelName).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Get logs file path
     - GET /endpoints/{deploymentName}/model/{modelName}/logfilepath
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{output=none}]
     - parameter deploymentName: (path) Name of the deployment group 
     - parameter modelName: (path) ID or name of the deployed model 
     - returns: RequestBuilder<String> 
     */
    open class func logfilepathWithRequestBuilder(deploymentName: String, modelName: String) -> RequestBuilder<String> {
        var path = "/endpoints/{deploymentName}/model/{modelName}/logfilepath"
        let deploymentNamePreEscape = "\(deploymentName)"
        let deploymentNamePostEscape = deploymentNamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{deploymentName}", with: deploymentNamePostEscape, options: .literal, range: nil)
        let modelNamePreEscape = "\(modelName)"
        let modelNamePostEscape = modelNamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelName}", with: modelNamePostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<String>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Post JSON credentials and obtain a JWT authorization token.
     - parameter credentials: (body) Login credentials. 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func login(credentials: Credentials, completion: @escaping ((_ data: Token?, _ error: ErrorResponse?) -> Void)) {
        loginWithRequestBuilder(credentials: credentials).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Post JSON credentials and obtain a JWT authorization token.
     - POST /login
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "token" : "xxxxxxx.yyyyyyy.zzzzzz"
}}]
     - parameter credentials: (body) Login credentials. 
     - returns: RequestBuilder<Token> 
     */
    open class func loginWithRequestBuilder(credentials: Credentials) -> RequestBuilder<Token> {
        let path = "/login"
        let URLString = SkilClientAPI.basePath + path
        let parameters = credentials.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Token>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Get logs
     - parameter body: (body) the the log request 
     - parameter deploymentName: (path) Name of the deployment group 
     - parameter modelName: (path) ID or name of the deployed model 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func logs(body: LogRequest, deploymentName: String, modelName: String, completion: @escaping ((_ data: LogBatch?, _ error: ErrorResponse?) -> Void)) {
        logsWithRequestBuilder(body: body, deploymentName: deploymentName, modelName: modelName).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Get logs
     - POST /endpoints/{deploymentName}/model/{modelName}/logs
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "offset" : 0,
  "rowCount" : 2,
  "logs" : "logs"
}}]
     - parameter body: (body) the the log request 
     - parameter deploymentName: (path) Name of the deployment group 
     - parameter modelName: (path) ID or name of the deployed model 
     - returns: RequestBuilder<LogBatch> 
     */
    open class func logsWithRequestBuilder(body: LogRequest, deploymentName: String, modelName: String) -> RequestBuilder<LogBatch> {
        var path = "/endpoints/{deploymentName}/model/{modelName}/logs"
        let deploymentNamePreEscape = "\(deploymentName)"
        let deploymentNamePostEscape = deploymentNamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{deploymentName}", with: deploymentNamePostEscape, options: .literal, range: nil)
        let modelNamePreEscape = "\(modelName)"
        let modelNamePostEscape = modelNamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelName}", with: modelNamePostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let parameters = body.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<LogBatch>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Represents all of the labels for a given classification
     - parameter body: (body) The input NDArray 
     - parameter modelURI: (path) The URI of the model 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func multiclassify(body: Prediction, modelURI: String, completion: @escaping ((_ data: MultiClassClassificationResult?, _ error: ErrorResponse?) -> Void)) {
        multiclassifyWithRequestBuilder(body: body, modelURI: modelURI).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Represents all of the labels for a given classification
     - POST /endpoints/{modelURI}/multiclassify
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "maxOutcomes" : [ "maxOutcomes", "maxOutcomes" ],
  "rankedOutcomes" : [ [ "rankedOutcomes", "rankedOutcomes" ], [ "rankedOutcomes", "rankedOutcomes" ] ],
  "probabilities" : [ [ 0.4, 0.4 ], [ 0.4, 0.4 ] ]
}}]
     - parameter body: (body) The input NDArray 
     - parameter modelURI: (path) The URI of the model 
     - returns: RequestBuilder<MultiClassClassificationResult> 
     */
    open class func multiclassifyWithRequestBuilder(body: Prediction, modelURI: String) -> RequestBuilder<MultiClassClassificationResult> {
        var path = "/endpoints/{modelURI}/multiclassify"
        let modelURIPreEscape = "\(modelURI)"
        let modelURIPostEscape = modelURIPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelURI}", with: modelURIPostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let parameters = body.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<MultiClassClassificationResult>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Run inference on the input array.
     - parameter body: (body) The input NDArray 
     - parameter modelURI: (path) The URI of the model 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func predict(body: Prediction, modelURI: String, completion: @escaping ((_ data: Prediction?, _ error: ErrorResponse?) -> Void)) {
        predictWithRequestBuilder(body: body, modelURI: modelURI).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Run inference on the input array.
     - POST /endpoints/{modelURI}/predict
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "needsPreProcessing" : true,
  "prediction" : {
    "array" : "array"
  },
  "id" : "id"
}}]
     - parameter body: (body) The input NDArray 
     - parameter modelURI: (path) The URI of the model 
     - returns: RequestBuilder<Prediction> 
     */
    open class func predictWithRequestBuilder(body: Prediction, modelURI: String) -> RequestBuilder<Prediction> {
        var path = "/endpoints/{modelURI}/predict"
        let modelURIPreEscape = "\(modelURI)"
        let modelURIPostEscape = modelURIPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelURI}", with: modelURIPostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let parameters = body.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Prediction>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Run inference on the input array, using input image file from multipart form data.
     - parameter modelURI: (path) The URI of the model 
     - parameter image: (form) The file to upload. (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func predictimage(modelURI: String, image: URL? = nil, completion: @escaping ((_ data: Prediction?, _ error: ErrorResponse?) -> Void)) {
        predictimageWithRequestBuilder(modelURI: modelURI, image: image).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Run inference on the input array, using input image file from multipart form data.
     - POST /endpoints/{modelURI}/predictimage
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "needsPreProcessing" : true,
  "prediction" : {
    "array" : "array"
  },
  "id" : "id"
}}]
     - parameter modelURI: (path) The URI of the model 
     - parameter image: (form) The file to upload. (optional)
     - returns: RequestBuilder<Prediction> 
     */
    open class func predictimageWithRequestBuilder(modelURI: String, image: URL? = nil) -> RequestBuilder<Prediction> {
        var path = "/endpoints/{modelURI}/predictimage"
        let modelURIPreEscape = "\(modelURI)"
        let modelURIPostEscape = modelURIPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelURI}", with: modelURIPostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let formParams: [String:Any?] = [
            "image": image
        ]

        let nonNullParameters = APIHelper.rejectNil(formParams)
        let parameters = APIHelper.convertBoolToString(nonNullParameters)

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Prediction>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Preprocesses the input and run inference on it
     - parameter body: (body) The input array 
     - parameter modelURI: (path) The URI of the model 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func predictwithpreprocess(body: [String], modelURI: String, completion: @escaping ((_ data: Prediction?, _ error: ErrorResponse?) -> Void)) {
        predictwithpreprocessWithRequestBuilder(body: body, modelURI: modelURI).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Preprocesses the input and run inference on it
     - POST /endpoints/{modelURI}/predictwithpreprocess
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "needsPreProcessing" : true,
  "prediction" : {
    "array" : "array"
  },
  "id" : "id"
}}]
     - parameter body: (body) The input array 
     - parameter modelURI: (path) The URI of the model 
     - returns: RequestBuilder<Prediction> 
     */
    open class func predictwithpreprocessWithRequestBuilder(body: [String], modelURI: String) -> RequestBuilder<Prediction> {
        var path = "/endpoints/{modelURI}/predictwithpreprocess"
        let modelURIPreEscape = "\(modelURI)"
        let modelURIPostEscape = modelURIPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelURI}", with: modelURIPostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let parameters = body.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Prediction>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Preprocesses the input and run inference on it and returns it as a JsonArrayResponse
     - parameter body: (body) The input array 
     - parameter modelURI: (path) The URI of the model 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func predictwithpreprocessjson(body: [String], modelURI: String, completion: @escaping ((_ data: JsonArrayResponse?, _ error: ErrorResponse?) -> Void)) {
        predictwithpreprocessjsonWithRequestBuilder(body: body, modelURI: modelURI).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Preprocesses the input and run inference on it and returns it as a JsonArrayResponse
     - POST /endpoints/{modelURI}/predictwithpreprocessjson
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "array" : {
    "array" : "array"
  }
}}]
     - parameter body: (body) The input array 
     - parameter modelURI: (path) The URI of the model 
     - returns: RequestBuilder<JsonArrayResponse> 
     */
    open class func predictwithpreprocessjsonWithRequestBuilder(body: [String], modelURI: String) -> RequestBuilder<JsonArrayResponse> {
        var path = "/endpoints/{modelURI}/predictwithpreprocessjson"
        let modelURIPreEscape = "\(modelURI)"
        let modelURIPostEscape = modelURIPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelURI}", with: modelURIPostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let parameters = body.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<JsonArrayResponse>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Change the state of model to \"start\" or \"stop\"
     - parameter deploymentId: (path) ID deployment group 
     - parameter modelId: (path) ID of model 
     - parameter body: (body) the state request 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func updateState(deploymentId: String, modelId: String, body: UpdateState, completion: @escaping ((_ data: Any?, _ error: ErrorResponse?) -> Void)) {
        updateStateWithRequestBuilder(deploymentId: deploymentId, modelId: modelId, body: body).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Change the state of model to \"start\" or \"stop\"
     - POST /deployment/{deploymentId}/model/{modelId}/state
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example="{}"}]
     - parameter deploymentId: (path) ID deployment group 
     - parameter modelId: (path) ID of model 
     - parameter body: (body) the state request 
     - returns: RequestBuilder<Any> 
     */
    open class func updateStateWithRequestBuilder(deploymentId: String, modelId: String, body: UpdateState) -> RequestBuilder<Any> {
        var path = "/deployment/{deploymentId}/model/{modelId}/state"
        let deploymentIdPreEscape = "\(deploymentId)"
        let deploymentIdPostEscape = deploymentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{deploymentId}", with: deploymentIdPostEscape, options: .literal, range: nil)
        let modelIdPreEscape = "\(modelId)"
        let modelIdPostEscape = modelIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{modelId}", with: modelIdPostEscape, options: .literal, range: nil)
        let URLString = SkilClientAPI.basePath + path
        let parameters = body.encodeToJSON()

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Any>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Upload a model file to SKIL for import.
     - parameter file: (form) The file to upload. (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func upload(file: URL? = nil, completion: @escaping ((_ data: FileUploadList?, _ error: ErrorResponse?) -> Void)) {
        uploadWithRequestBuilder(file: file).execute { (response, error) -> Void in
            completion(response?.body, error)
        }
    }


    /**
     Upload a model file to SKIL for import.
     - POST /api/upload/model
     - API Key:
       - type: apiKey authorization 
       - name: api_key
     - examples: [{contentType=application/json, example={
  "fileUploadResponseList" : [ {
    "path" : "path",
    "fileName" : "fileName",
    "type" : "type",
    "key" : "key",
    "fileContent" : "fileContent",
    "status" : "status"
  }, {
    "path" : "path",
    "fileName" : "fileName",
    "type" : "type",
    "key" : "key",
    "fileContent" : "fileContent",
    "status" : "status"
  } ]
}}]
     - parameter file: (form) The file to upload. (optional)
     - returns: RequestBuilder<FileUploadList> 
     */
    open class func uploadWithRequestBuilder(file: URL? = nil) -> RequestBuilder<FileUploadList> {
        let path = "/api/upload/model"
        let URLString = SkilClientAPI.basePath + path
        let formParams: [String:Any?] = [
            "file": file
        ]

        let nonNullParameters = APIHelper.rejectNil(formParams)
        let parameters = APIHelper.convertBoolToString(nonNullParameters)

        let url = NSURLComponents(string: URLString)

        let requestBuilder: RequestBuilder<FileUploadList>.Type = SkilClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

}
